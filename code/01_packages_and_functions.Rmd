---
title: "01 Packages and functions"
output: html_notebook
---


# Load packages

```{r}
library('plyr') # merge data in a tidyverse way 
# NOTE: since plyr is not formally part of the tidyverse, it must be loaded
# before tidyverse or dplyr
library('stringi') # advanced string manipulation 
# NOTE: it's usually better to use the wrappers in stringr, which is why that is 
# loaded (as part of tidyverse) after this
library('reshape2') # for creating tables of offence categories
library('tidyverse')
library("lubridate") # date handlind
library('sf') # handle spatial data
```


# Set parameters

```{r}
# Set parameters
yearFirst <- 2007
yearLast <- 2017
city_data <- list(
  'Chicago' = list('FIPS_code' = '17', 'name' = 'Chicago', 'prefix' = 'chi', 'abbr' = 'IL'),
  'Detroit' = list('FIPS_code' = '26', 'name' = 'Detroit', 'prefix' = 'dtt', 'abbr' = 'MI'),
  'FW' = list('FIPS_code' = '48', 'name' = 'Fort Worth', 'prefix' = 'ftw', 'abbr' = 'TX'),
  'LA' = list('FIPS_code' = '06', 'name' = 'Los Angeles', 'prefix' = 'lax', 'abbr' = 'CA'),
  'Louisville' = list('FIPS_code' = '21', 'name' = 'Louisville', 'prefix' = 'lou', 'abbr' = 'KY', 'start' = 2004),
  'NO' = list('FIPS_code' = '22', 'name' = 'New Orleans', 'prefix' = 'nor', 'abbr' = 'LA'),
  'NYC' = list('FIPS_code' = '36', 'name' = 'New York', 'prefix' = 'nyc', 'abbr' = 'NY', 'start' = 2007),
  'SF' = list('FIPS_code' = '06', 'name' = 'San Francisco', 'prefix' = 'sfo', 'abbr' = 'CA'),
  'VB' = list('FIPS_code' = '51', 'name' = 'Virginia Beach', 'prefix' = 'vib', 'abbr' = 'VA', 'start' = 2013)
)

nibrs_categories <- read_csv("../crime_categories/NIBRS categories.csv") %>% 
  rename(Offense = NIBRS_Offense_Code_1)

cities <- tribble(
  ~name, ~fips, ~prefix,
  "Chicago",        "17", "chi",
  "Detroit",        "26", "dtt",
  "Fort Worth",     "48", "ftw",
  "Los Angeles",    "06", "lax",
  "Louisville",     "21", "lou",
  "New York",       "36", "nyc",
  "San Francisco",  "06", "sfo",
  "Seattle",        "53", "sea",
  "Tucson",         "04", "tus",
  "Virginia Beach", "51", "vib"
)
```


# Functions

## Report status within pipeline

This function passes through an object while printing a message and optionally
printing a summary of the object.

```{r}
report_status <- function(data, message, summary = FALSE) {
  
  # if necessary, add a summary of the object to the message
  if (summary == TRUE) {
    message <- paste0(
      message, 
      " (data is ", 
      class(data), 
      ifelse(is.null(nrow(data)) | is.null(ncol(data)), 
             paste(" of length", length(data)),
             paste(" with", ncol(data), "columns and", nrow(data), "rows")), 
      ")")
  }
  
  # print message
  cat(message, "\n")
  
  # return the object unchanged
  data

}
```


## Add date to data

This function extracts a date from the data, converts it to a common format and
creates a new column showing the year (which is needed for filtering later).

```{r}
add_date_var <- function (data, field_name, date_format, tz) {
  if (!is_tibble(data)) {
    stop("data must be a tibble")
  }
  if (!is.character(field_name)) {
    stop("field_name must be a character string")
  }
  if (!has_name(data, field_name)) {
    stop("field_name must be the name of a column in data")
  }
  if (!is.character(date_format)) {
    stop("date_format must be a character string")
  }
  if (!is.character(tz)) {
    stop("tz must be a character string")
  }
  
  data <- data %>% mutate(
    Date.Temp = parse_date_time((!!as.name(field_name)), date_format, tz = tz),
    Date.Year = year(Date.Temp),
    Date.Single = strftime(Date.Temp, format = '%Y-%m-%d %H:%M', tz = tz),
    Multiple.Dates = FALSE
  ) %>% 
    select(-Date.Temp)
  
  if (sum(is.na(data$Date.Single)) > 0) {
    cat("\n✖︎", format(sum(is.na(data$Date.Single)), big.mark = ","), 
        "dates could not be parsed. Sample of original field:\n")
    data %>% 
      filter(is.na(data$Date.Single)) %>% 
      sample_n(10) %>% { print(.[[field_name]]) }
  } else {
    cat("✔︎ All dates parsed\n")
  }
  
  data
}
```

## Filter data by year

```{r}
filter_by_year <- function (data, year_first, year_last) {
  if (!is_tibble(data)) {
    stop("data must be a tibble")
  }
  if (!has_name(data, "Date.Year")) {
    stop("data must include a column named 'Date.Year'")
  }
  if (!is.numeric(year_first) | !is.numeric(year_last)) {
    stop("year_first and year_last must be integers")
  }
  
  year_range <- range(data$Date.Year, na.rm = TRUE)
  
  cat("Original data includes", format(nrow(data), big.mark = ","), 
      "crimes between", year_range[1], "and", year_range[2], "\n")
  
  filtered_data <- data %>% 
    filter(Date.Year >= year_first & Date.Year <= year_last)
  
  year_range <- range(filtered_data$Date.Year)
  
  cat(format(nrow(data) - nrow(filtered_data), big.mark = ","), 
      "rows removed", "\nFiltered data includes", 
      format(nrow(filtered_data), big.mark = ","), "crimes between", 
      year_range[1], "and", year_range[2], "\n")
  
  if (min(table(filtered_data$Date.Year)) < 1000) {
    warning("✖ Some years have fewer than 1,000 crimes\n")
    print(table(filtered_data$Date.Year))
  }

  filtered_data

}
```

## Join crime categories

```{r}
join_nibrs_cats <- function (data, file, by) {
  
  cats <- read_csv(file)
  
  data <- left_join(data, cats, by = by)
  
  check_nibrs_cats(data, file, by)
  
  data
  
}

```

## Check if crime categories are correctly matched

```{r}
check_nibrs_cats <- function (data, file, by) {
  
  if (sum(is.na(data$NIBRS_Offense_Type)) > 0) {
    cat("✖︎", format(sum(is.na(data$NIBRS_Offense_Type)), big.mark = ","), 
        "cases could not be matched to NIBRS categories\n")
    filter(data, is.na(data$NIBRS_Offense_Type)) %>% 
      group_by_at(vars(one_of(c(by, "Date.Year")))) %>% 
      summarise(n = n()) %>% 
      spread(Date.Year, n) %>% 
      write_csv(paste0(file, "_failures.csv"))
  } else {
    cat("✔︎ All cases matched to NIBRS categories\n")
  }
  
  data
  
}
```


## Write temporary data file

This function also adds a UID field to the data and returns a count of the data.

```{r}
save_city_data <- function (data, name) {
  if (!is_tibble(data)) {
    stop("data should be a tibble")
  }
  if (!is.character(name)) {
    stop("name must be a character string")
  }
  
  data <- data %>% mutate(
    UID = 1:nrow(.),
    city_name = str_to_title(name)
  )
  
  saveRDS(data, paste0("../temp_data/raw_", 
                       str_replace_all(str_to_lower(name), "\\s", "_"), 
                       "_data.Rds"))
  
  data %>% 
    nrow() %>% 
    format(big.mark = ',') %>% 
    cat("Data for", str_to_title(name), "contains", ., "rows\n")
  
  print(table(data$Date.Year))
  
  data
  
}
```

